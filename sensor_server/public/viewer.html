<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniversalPointer 3D Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
        }

        .badge {
            background: #007bff;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="info">
        <span class="badge">PRO V2</span> 3D Visualization Room<br>
        Status: <span id="status">Disconnected</span><br>
        Wall: <span id="wall">None</span><br>
        <div id="debug"
            style="margin-top:10px; font-family:monospace; color:#aaa; font-size:10px; border-top:1px solid #333; padding-top:5px;">
            X: <span id="valX">0.00</span> | Y: <span id="valY">0.00</span> | Z: <span id="valZ">0.00</span>
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 3, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x00ffff, 2, 10);
        pointLight.position.set(0, 1, 0);
        scene.add(pointLight);

        // Room Dimensions (Meters) - Should match Python config
        const W = 4.0, H = 3.0, D = 5.0;

        // Materials
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x111111, side: THREE.DoubleSide, metalness: 0.5, roughness: 0.2 });
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.1 });
        const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Create Room (Floor is at Y=0)
        // Back Wall
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), wallMat);
        backWall.position.z = -D / 2;
        backWall.position.y = H / 2;
        scene.add(backWall);
        scene.add(new THREE.AxesHelper(1)); // Add Axis helper at center

        // Floor
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);

        // Left Wall
        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.x = -W / 2;
        leftWall.position.y = H / 2;
        scene.add(leftWall);

        // Right Wall
        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.position.x = W / 2;
        rightWall.position.y = H / 2;
        scene.add(rightWall);

        // Pointer Light & Glow
        const laserMat = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
        const laserGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 1.0, 0), new THREE.Vector3(0, 1.0, -1)]);
        const laserLine = new THREE.Line(laserGeom, laserMat);
        scene.add(laserLine);

        // Pointer Light
        const pointerLight = new THREE.PointLight(0xff0000, 5, 2);
        scene.add(pointerLight);

        // Glow Sprite (Textureless procedural glow)
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 30);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.3, 'rgba(255, 0, 0, 0.8)');
            grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
            map: createGlowTexture(),
            blending: THREE.AdditiveBlending,
            transparent: true
        }));
        glowSprite.scale.set(0.3, 0.3, 1);
        scene.add(glowSprite);

        // Origin Marker (User)
        const userGeom = new THREE.CylinderGeometry(0.02, 0.05, 0.2);
        const userMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const user = new THREE.Mesh(userGeom, userMat);
        user.rotation.x = Math.PI / 2;
        user.position.y = 1.0; // Place human-height relative to floor
        scene.add(user);

        // WebSocket Link
        let ws;
        function connect() {
            ws = new WebSocket(`ws://${location.host}/?type=viewer`);
            ws.onopen = () => {
                document.getElementById('status').innerText = 'Connected';
                document.getElementById('status').style.color = '#0f0';
            };
            ws.onclose = () => {
                document.getElementById('status').innerText = 'Disconnected';
                document.getElementById('status').style.color = '#f00';
                setTimeout(connect, 2000);
            };
            ws.onmessage = (e) => {
                const data = JSON.parse(e.data);
                if (data.type === '3d_move') {
                    const targetPos = new THREE.Vector3(data.x, data.y + 1.0, data.z);
                    const startPos = new THREE.Vector3(0, 1.0, 0);

                    // Update pointer visuals
                    pointerLight.position.copy(targetPos);
                    glowSprite.position.copy(targetPos);

                    // Offset glow slightly away from wall to avoid z-fighting
                    const dir = targetPos.clone().sub(startPos).normalize();
                    glowSprite.position.sub(dir.multiplyScalar(0.02));

                    // Update laser line
                    laserLine.geometry.setFromPoints([startPos, targetPos]);

                    // Update info
                    document.getElementById('wall').innerText = data.wall || 'Unknown';
                    document.getElementById('valX').innerText = data.x.toFixed(2);
                    document.getElementById('valY').innerText = data.y.toFixed(2);
                    document.getElementById('valZ').innerText = data.z.toFixed(2);

                    // Dynamic color based on wall
                    const colors = { 'Front': 0x00ffff, 'Left': 0xff00ff, 'Right': 0xffff00, 'Floor': 0x00ff00, 'Back': 0xff0000 };
                    const hex = colors[data.wall] || 0xff0000;
                    pointerLight.color.setHex(hex);
                    laserLine.material.color.setHex(hex);
                    glowSprite.material.color.setHex(hex);
                }
            };
        }

        connect();

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>