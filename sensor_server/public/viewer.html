<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniversalPointer 3D Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Consolas', monospace;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
        }

        #dataPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            color: #fff;
            font-size: 14px;
            min-width: 250px;
            pointer-events: none;
        }

        .dataBox {
            background: rgba(0, 50, 50, 0.5);
            border: 1px solid #00ffff;
            border-radius: 4px;
            padding: 8px;
            margin: 8px 0;
        }

        .dataLabel {
            color: #00ffff;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .dataValue {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .badge {
            background: #007bff;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="info">
        <span class="badge">PRO V2</span> 3D Visualization<br>
        Status: <span id="status">Disconnected</span>
    </div>

    <div id="dataPanel">
        <div style="color: #00ffff; font-size: 16px; margin-bottom: 10px; border-bottom: 1px solid #00ffff; padding-bottom: 5px;">
            SENSOR DATA
        </div>

        <div class="dataBox">
            <div class="dataLabel">Wall Surface</div>
            <div class="dataValue" id="wall">None</div>
        </div>

        <div class="dataBox">
            <div class="dataLabel">Position X (m)</div>
            <div class="dataValue" id="valX">0.00</div>
        </div>

        <div class="dataBox">
            <div class="dataLabel">Position Y (m)</div>
            <div class="dataValue" id="valY">0.00</div>
        </div>

        <div class="dataBox">
            <div class="dataLabel">Position Z (m)</div>
            <div class="dataValue" id="valZ">0.00</div>
        </div>

        <div class="dataBox">
            <div class="dataLabel">Decal Radius</div>
            <div class="dataValue" id="decalRadius">0.60 m</div>
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 3, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Improved Lighting for better visibility and depth
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight1.position.set(3, 5, 3);
        scene.add(dirLight1);
        const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
        dirLight2.position.set(-3, 3, -3);
        scene.add(dirLight2);

        // Room Dimensions (Meters) - Should match Python config
        const W = 4.0, H = 3.0, D = 5.0;

        // Materials (WIREFRAME MODE)
        const wallMat = new THREE.MeshBasicMaterial({
            color: 0x444444,
            wireframe: true,
            wireframeLinewidth: 1
        });
        const floorMat = new THREE.MeshBasicMaterial({
            color: 0x333333,
            wireframe: true,
            wireframeLinewidth: 1
        });
        const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Create Room (Floor is at Y=0)
        // Back Wall
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), wallMat);
        backWall.position.z = -D / 2;
        backWall.position.y = H / 2;
        scene.add(backWall);
        scene.add(new THREE.AxesHelper(1)); // Add Axis helper at center

        // Floor
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);

        // Left Wall
        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.x = -W / 2;
        leftWall.position.y = H / 2;
        scene.add(leftWall);

        // Right Wall
        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.position.x = W / 2;
        rightWall.position.y = H / 2;
        scene.add(rightWall);

        // Add edge highlights to all walls (bright white for visibility)
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });

        function addEdges(mesh) {
            const edges = new THREE.EdgesGeometry(mesh.geometry);
            const line = new THREE.LineSegments(edges, edgeMaterial);
            line.position.copy(mesh.position);
            line.rotation.copy(mesh.rotation);
            scene.add(line);
        }

        addEdges(backWall);
        addEdges(floor);
        addEdges(leftWall);
        addEdges(rightWall);

        // Wall mesh references for decal projection
        const wallMeshes = {
            'Back': backWall,
            'Left': leftWall,
            'Right': rightWall,
            'Floor': floor
        };

        // Laser Line (visible in wireframe mode)
        const laserMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
        const laserGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 1.0, 0), new THREE.Vector3(0, 1.0, -1)]);
        const laserLine = new THREE.Line(laserGeom, laserMat);
        scene.add(laserLine);

        // Decal properties (independent behavior)
        const DECAL_RADIUS = 0.6;  // Radius in meters (50% larger)

        // Dynamic deformable mesh that follows geometry and simulates wall collision
        const dynamicGeometry = new THREE.BufferGeometry();
        const dynamicMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true,
            wireframeLinewidth: 2,
            side: THREE.DoubleSide
        });

        const dynamicMesh = new THREE.Mesh(dynamicGeometry, dynamicMaterial);
        scene.add(dynamicMesh);

        // Smooth interpolation state for geometry transitions between walls
        let previousVertices = null;
        let targetVertices = null;
        let interpolationProgress = 1.0;
        const INTERPOLATION_SPEED = 0.08; // Slower for smoother wall transitions

        // Smoothstep easing function for smoother wall transitions
        function smoothstep(t) {
            return t * t * (3 - 2 * t);
        }

        // Generate mesh that TRULY follows wall geometry with proper bending
        // Vertices are constrained to actual wall planes
        function generateAdaptiveCircle(surfaces) {
            const vertices = [];
            const indices = [];
            const segments = 64;

            if (surfaces.length === 1) {
                // Single surface - normal circle on that surface
                const surface = surfaces[0];
                const center = surface.point;
                const normal = surface.normal;

                // Build local coordinate system
                const tangent1 = new THREE.Vector3();
                const tangent2 = new THREE.Vector3();

                if (Math.abs(normal.y) < 0.9) {
                    tangent1.crossVectors(normal, new THREE.Vector3(0, 1, 0)).normalize();
                } else {
                    tangent1.crossVectors(normal, new THREE.Vector3(1, 0, 0)).normalize();
                }
                tangent2.crossVectors(normal, tangent1).normalize();

                // Center + offset
                const offsetCenter = center.clone().add(normal.clone().multiplyScalar(0.01));
                vertices.push(offsetCenter.x, offsetCenter.y, offsetCenter.z);

                // Circle vertices ON the surface
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const x = Math.cos(angle) * DECAL_RADIUS;
                    const y = Math.sin(angle) * DECAL_RADIUS;

                    const pos = center.clone()
                        .add(tangent1.clone().multiplyScalar(x))
                        .add(tangent2.clone().multiplyScalar(y))
                        .add(normal.clone().multiplyScalar(0.01));

                    vertices.push(pos.x, pos.y, pos.z);

                    if (i < segments) {
                        indices.push(0, i + 1, i + 2);
                    }
                }

            } else {
                // Multiple surfaces - mesh bends along corner edges
                // Each vertex is CLAMPED to its corresponding wall plane

                // We'll create a circle in 3D space, then clamp each vertex to the nearest surface
                // This creates a natural "bending" effect along corner edges

                const avgCenter = new THREE.Vector3();
                surfaces.forEach(s => avgCenter.add(s.point));
                avgCenter.divideScalar(surfaces.length);

                // Average normal for reference orientation
                const avgNormal = new THREE.Vector3();
                surfaces.forEach(s => avgNormal.add(s.normal));
                avgNormal.normalize();

                // Build reference coordinate system
                const refTangent1 = new THREE.Vector3();
                const refTangent2 = new THREE.Vector3();

                if (Math.abs(avgNormal.y) < 0.9) {
                    refTangent1.crossVectors(avgNormal, new THREE.Vector3(0, 1, 0)).normalize();
                } else {
                    refTangent1.crossVectors(avgNormal, new THREE.Vector3(1, 0, 0)).normalize();
                }
                refTangent2.crossVectors(avgNormal, refTangent1).normalize();

                // Add center vertex
                vertices.push(avgCenter.x, avgCenter.y, avgCenter.z);

                // Generate circle vertices, clamping each to its nearest wall plane
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const x = Math.cos(angle) * DECAL_RADIUS;
                    const y = Math.sin(angle) * DECAL_RADIUS;

                    // Ideal position in 3D space (unclamped)
                    const idealPos = avgCenter.clone()
                        .add(refTangent1.clone().multiplyScalar(x))
                        .add(refTangent2.clone().multiplyScalar(y));

                    // Find which surface this vertex should belong to
                    // by checking which surface it's closest to or which one it "faces"
                    let bestSurface = surfaces[0];
                    let minDist = Infinity;

                    surfaces.forEach(surf => {
                        // Project ideal position onto this surface's plane
                        const toIdeal = idealPos.clone().sub(surf.point);
                        const distToPlane = Math.abs(toIdeal.dot(surf.normal));

                        if (distToPlane < minDist) {
                            minDist = distToPlane;
                            bestSurface = surf;
                        }
                    });

                    // Clamp vertex to the selected surface's plane
                    const toIdeal = idealPos.clone().sub(bestSurface.point);
                    const distAlongNormal = toIdeal.dot(bestSurface.normal);
                    const clampedPos = idealPos.clone().sub(
                        bestSurface.normal.clone().multiplyScalar(distAlongNormal - 0.01)
                    );

                    vertices.push(clampedPos.x, clampedPos.y, clampedPos.z);

                    // Create triangle fan from center
                    if (i < segments) {
                        indices.push(0, i + 1, i + 2);
                    }
                }
            }

            return { vertices, indices, borderVertices: [] };
        }

        // Raycaster for surface detection
        const surfaceRaycaster = new THREE.Raycaster();
        const raycastableWalls = [backWall, leftWall, rightWall, floor];


        // Update dynamic mesh - deforms to follow geometry and simulate collision
        function updateCrawlingCircle(x, y, z) {
            const origin = new THREE.Vector3(0, 1.0, 0); // User position
            const targetPoint = new THREE.Vector3(x, y, z);

            // Cast ray from user to target point
            const direction = targetPoint.clone().sub(origin).normalize();
            surfaceRaycaster.set(origin, direction);

            // Find primary intersection
            const intersections = surfaceRaycaster.intersectObjects(raycastableWalls, false);

            if (intersections.length > 0) {
                const primaryIntersection = intersections[0];
                const primaryPoint = primaryIntersection.point;

                // Detect all nearby surfaces within circle radius
                const nearbySurfaces = [];
                const EDGE_THRESHOLD = DECAL_RADIUS * 0.8; // Activate when within 80% of radius

                // Primary surface always included
                const primaryNormal = primaryIntersection.face.normal.clone();
                primaryNormal.transformDirection(primaryIntersection.object.matrixWorld);

                nearbySurfaces.push({
                    mesh: primaryIntersection.object,
                    point: primaryPoint.clone(),
                    normal: primaryNormal
                });

                // Check proximity to edges/corners
                const px = primaryPoint.x;
                const py = primaryPoint.y;
                const pz = primaryPoint.z;

                // Check if near Back wall (z = -D/2)
                if (Math.abs(pz - (-D/2)) < EDGE_THRESHOLD && primaryIntersection.object !== backWall) {
                    const projPoint = new THREE.Vector3(px, py, -D/2);
                    const normal = new THREE.Vector3(0, 0, 1);
                    nearbySurfaces.push({ mesh: backWall, point: projPoint, normal });
                }

                // Check if near Left wall (x = -W/2)
                if (Math.abs(px - (-W/2)) < EDGE_THRESHOLD && primaryIntersection.object !== leftWall) {
                    const projPoint = new THREE.Vector3(-W/2, py, pz);
                    const normal = new THREE.Vector3(1, 0, 0);
                    nearbySurfaces.push({ mesh: leftWall, point: projPoint, normal });
                }

                // Check if near Right wall (x = W/2)
                if (Math.abs(px - (W/2)) < EDGE_THRESHOLD && primaryIntersection.object !== rightWall) {
                    const projPoint = new THREE.Vector3(W/2, py, pz);
                    const normal = new THREE.Vector3(-1, 0, 0);
                    nearbySurfaces.push({ mesh: rightWall, point: projPoint, normal });
                }

                // Check if near Floor (y = 0)
                if (Math.abs(py - 0) < EDGE_THRESHOLD && primaryIntersection.object !== floor) {
                    const projPoint = new THREE.Vector3(px, 0, pz);
                    const normal = new THREE.Vector3(0, 1, 0);
                    nearbySurfaces.push({ mesh: floor, point: projPoint, normal });
                }

                // Generate adaptive geometry that deforms around corners
                const { vertices, indices, borderVertices } = generateAdaptiveCircle(nearbySurfaces);

                const surfaceNames = nearbySurfaces.map(s => {
                    if (s.mesh === backWall) return 'Back';
                    if (s.mesh === leftWall) return 'Left';
                    if (s.mesh === rightWall) return 'Right';
                    if (s.mesh === floor) return 'Floor';
                    return 'Unknown';
                });
                console.log(`[MESH] Surfaces: [${surfaceNames.join(', ')}] | Vertices: ${vertices.length/3} | Triangles: ${indices.length/3}`);

                // Smooth interpolation to avoid jumps
                if (targetVertices === null || targetVertices.length !== vertices.length) {
                    // First time or topology changed - snap immediately
                    targetVertices = vertices.slice();
                    previousVertices = vertices.slice();
                    interpolationProgress = 1.0;
                } else {
                    // Smooth transition
                    previousVertices = dynamicGeometry.attributes.position ?
                        Array.from(dynamicGeometry.attributes.position.array) :
                        targetVertices.slice();
                    targetVertices = vertices.slice();
                    interpolationProgress = 0.0; // Start interpolation
                }

                // Update geometry (will be interpolated in animate loop)
                if (!dynamicGeometry.attributes.position) {
                    dynamicGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                }
                dynamicGeometry.setIndex(indices);
                dynamicGeometry.computeVertexNormals();
                dynamicMesh.visible = true;

            } else {
                // No intersection - hide mesh
                dynamicMesh.visible = false;
            }
        }

        // Origin Marker (User)
        const userGeom = new THREE.CylinderGeometry(0.02, 0.05, 0.2);
        const userMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const user = new THREE.Mesh(userGeom, userMat);
        user.rotation.x = Math.PI / 2;
        user.position.y = 1.0; // Place human-height relative to floor
        scene.add(user);

        // WebSocket Link
        let ws;
        function connect() {
            ws = new WebSocket(`ws://${location.host}/?type=viewer`);
            ws.onopen = () => {
                document.getElementById('status').innerText = 'Connected';
                document.getElementById('status').style.color = '#0f0';
            };
            ws.onclose = () => {
                document.getElementById('status').innerText = 'Disconnected';
                document.getElementById('status').style.color = '#f00';
                setTimeout(connect, 2000);
            };
            ws.onmessage = (e) => {
                const data = JSON.parse(e.data);
                if (data.type === '3d_move') {
                    const targetPos = new THREE.Vector3(data.x, data.y + 1.0, data.z);
                    const startPos = new THREE.Vector3(0, 1.0, 0);

                    // Update crawling circle that adapts to geometry
                    updateCrawlingCircle(data.x, data.y + 1.0, data.z);

                    // Update laser line
                    laserLine.geometry.setFromPoints([startPos, targetPos]);

                    // Update info
                    document.getElementById('wall').innerText = data.wall || 'Unknown';
                    document.getElementById('valX').innerText = data.x.toFixed(2);
                    document.getElementById('valY').innerText = data.y.toFixed(2);
                    document.getElementById('valZ').innerText = data.z.toFixed(2);

                    // Dynamic color based on wall
                    const colors = { 'Front': 0x00ffff, 'Left': 0xff00ff, 'Right': 0xffff00, 'Floor': 0x00ff00, 'Back': 0xff0000 };
                    const hex = colors[data.wall] || 0xff0000;
                    laserLine.material.color.setHex(hex);

                    // Update color for dynamic mesh
                    if (dynamicMesh.visible) {
                        dynamicMaterial.color.setHex(hex);
                    }
                }
            };
        }

        connect();

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Smooth vertex interpolation to avoid jumps during surface transitions
            if (interpolationProgress < 1.0 && previousVertices && targetVertices && dynamicMesh.visible) {
                interpolationProgress = Math.min(1.0, interpolationProgress + INTERPOLATION_SPEED);

                // Apply smoothstep easing for smoother transitions
                const easedProgress = smoothstep(interpolationProgress);

                const posAttr = dynamicGeometry.attributes.position;
                for (let i = 0; i < posAttr.count * 3; i++) {
                    const prev = previousVertices[i];
                    const target = targetVertices[i];
                    posAttr.array[i] = prev + (target - prev) * easedProgress;
                }
                posAttr.needsUpdate = true;
                dynamicGeometry.computeVertexNormals();
            }

            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>