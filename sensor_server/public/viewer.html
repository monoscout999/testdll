<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniversalPointer 3D Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Consolas', monospace;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
        }

        #dataPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            color: #fff;
            font-size: 14px;
            min-width: 250px;
            pointer-events: auto;
        }

        .dataBox {
            background: rgba(0, 50, 50, 0.5);
            border: 1px solid #00ffff;
            border-radius: 4px;
            padding: 8px;
            margin: 8px 0;
        }

        .dataLabel {
            color: #00ffff;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .dataValue {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .badge {
            background: #007bff;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="info">
        <span class="badge">PRO V2</span> 3D Visualization<br>
        Status: <span id="status">Disconnected</span>
    </div>

    <div id="dataPanel">
        <div style="color: #00ffff; font-size: 16px; margin-bottom: 10px; border-bottom: 1px solid #00ffff; padding-bottom: 5px;">
            SENSOR DATA
        </div>

        <div class="dataBox">
            <div class="dataLabel">Wall Surface</div>
            <div class="dataValue" id="wall">None</div>
        </div>

        <div class="dataBox">
            <div class="dataLabel">Position X (m)</div>
            <div class="dataValue" id="valX">0.00</div>
        </div>

        <div class="dataBox">
            <div class="dataLabel">Position Y (m)</div>
            <div class="dataValue" id="valY">0.00</div>
        </div>

        <div class="dataBox">
            <div class="dataLabel">Position Z (m)</div>
            <div class="dataValue" id="valZ">0.00</div>
        </div>

        <div class="dataBox" style="pointer-events: auto;">
            <div class="dataLabel">Cone Radius</div>
            <div class="dataValue" id="coneRadius">3.60 m</div>
            <input type="range" id="radiusSlider" min="0.3" max="10.0" step="0.1" value="3.6" style="width: 100%; margin-top: 5px; accent-color: #00ff00; cursor: pointer; pointer-events: auto;">
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.3/build/index.module.js",
                "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.17/build/index.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Brush, Evaluator, INTERSECTION, ADDITION } from 'three-bvh-csg';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 3, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Improved Lighting for better visibility and depth
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight1.position.set(3, 5, 3);
        scene.add(dirLight1);
        const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
        dirLight2.position.set(-3, 3, -3);
        scene.add(dirLight2);

        // Room Dimensions (Meters) - Should match Python config
        const W = 4.0, H = 3.0, D = 5.0;

        // Materials (WIREFRAME MODE)
        const wallMat = new THREE.MeshBasicMaterial({
            color: 0x444444,
            wireframe: true,
            wireframeLinewidth: 1
        });
        const floorMat = new THREE.MeshBasicMaterial({
            color: 0x333333,
            wireframe: true,
            wireframeLinewidth: 1
        });
        const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Create Room (Floor is at Y=0)
        // Back Wall
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), wallMat);
        backWall.position.z = -D / 2;
        backWall.position.y = H / 2;
        scene.add(backWall);
        scene.add(new THREE.AxesHelper(1)); // Add Axis helper at center

        // Floor
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);

        // Left Wall
        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.x = -W / 2;
        leftWall.position.y = H / 2;
        scene.add(leftWall);

        // Right Wall
        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.position.x = W / 2;
        rightWall.position.y = H / 2;
        scene.add(rightWall);

        // Add edge highlights to all walls (bright white for visibility)
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });

        function addEdges(mesh) {
            const edges = new THREE.EdgesGeometry(mesh.geometry);
            const line = new THREE.LineSegments(edges, edgeMaterial);
            line.position.copy(mesh.position);
            line.rotation.copy(mesh.rotation);
            scene.add(line);
        }

        addEdges(backWall);
        addEdges(floor);
        addEdges(leftWall);
        addEdges(rightWall);

        // Wall mesh references for decal projection
        const wallMeshes = {
            'Back': backWall,
            'Left': leftWall,
            'Right': rightWall,
            'Floor': floor
        };

        // Laser Line (visible in wireframe mode)
        const laserMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
        const laserGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 1.0, 0), new THREE.Vector3(0, 1.0, -1)]);
        const laserLine = new THREE.Line(laserGeom, laserMat);
        scene.add(laserLine);

        // CSG Setup
        const evaluator = new Evaluator();
        const DECAL_RADIUS = 3.6; // 6x más grande (doble del anterior)
        const CONE_LENGTH = 20.0;

        // Material para paredes invisibles
        const wallCSGMaterial = new THREE.MeshBasicMaterial({
            visible: false
        });

        // Crear brushes de las paredes
        const wallThickness = 0.01;

        const backWallBrush = new Brush(new THREE.BoxGeometry(W, H, wallThickness), wallCSGMaterial);
        backWallBrush.position.set(0, H/2, -D/2);
        backWallBrush.updateMatrixWorld();

        const floorBrush = new Brush(new THREE.BoxGeometry(W, wallThickness, D), wallCSGMaterial);
        floorBrush.position.set(0, 0, 0);
        floorBrush.updateMatrixWorld();

        const leftWallBrush = new Brush(new THREE.BoxGeometry(wallThickness, H, D), wallCSGMaterial);
        leftWallBrush.position.set(-W/2, H/2, 0);
        leftWallBrush.updateMatrixWorld();

        const rightWallBrush = new Brush(new THREE.BoxGeometry(wallThickness, H, D), wallCSGMaterial);
        rightWallBrush.position.set(W/2, H/2, 0);
        rightWallBrush.updateMatrixWorld();

        // Combinar todas las paredes en un solo targetBrush
        let targetBrush = evaluator.evaluate(backWallBrush, floorBrush, ADDITION);
        targetBrush.updateMatrixWorld();
        targetBrush = evaluator.evaluate(targetBrush, leftWallBrush, ADDITION);
        targetBrush.updateMatrixWorld();
        targetBrush = evaluator.evaluate(targetBrush, rightWallBrush, ADDITION);
        targetBrush.updateMatrixWorld();

        // Cono (herramienta)
        const coneGeo = new THREE.ConeGeometry(DECAL_RADIUS, CONE_LENGTH, 32);
        coneGeo.translate(0, -CONE_LENGTH / 2, 0); // Punta en origen

        const coneMaterial = new THREE.MeshBasicMaterial({
            color: 0x0000ff,
            wireframe: true,
            transparent: true,
            opacity: 0.1,
            visible: false
        });
        const coneBrush = new Brush(coneGeo, coneMaterial);
        scene.add(coneBrush);

        // Resultado de la intersección
        const resultMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true,
            wireframeLinewidth: 3,
            side: THREE.DoubleSide
        });
        const resultMesh = new THREE.Mesh(new THREE.BufferGeometry(), resultMaterial);
        scene.add(resultMesh);

        console.log('CSG setup complete');

        // Función de actualización CSG
        function updateCrawlingCircle(x, y, z) {
            const origin = new THREE.Vector3(0, 1.0, 0);
            const targetPoint = new THREE.Vector3(x, y, z);
            const direction = new THREE.Vector3().subVectors(targetPoint, origin).normalize();

            // Posicionar cono - punta en origen, apuntando hacia target
            coneBrush.position.copy(origin);
            coneBrush.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), direction);
            coneBrush.updateMatrixWorld();

            // Operación booleana CSG
            try {
                targetBrush.updateMatrixWorld();
                const tempResult = evaluator.evaluate(targetBrush, coneBrush, INTERSECTION);

                if (tempResult && tempResult.geometry) {
                    if (resultMesh.geometry) resultMesh.geometry.dispose();
                    resultMesh.geometry = tempResult.geometry;

                    const pos = resultMesh.geometry.attributes.position;
                    resultMesh.visible = (pos && pos.count > 0);
                }
            } catch (e) {
                console.warn("Error CSG:", e);
                resultMesh.visible = false;
            }
        }

        // Origin Marker (User)
        const userGeom = new THREE.CylinderGeometry(0.02, 0.05, 0.2);
        const userMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const user = new THREE.Mesh(userGeom, userMat);
        user.rotation.x = Math.PI / 2;
        user.position.y = 1.0; // Place human-height relative to floor
        scene.add(user);

        // WebSocket Link
        let ws;
        function connect() {
            ws = new WebSocket(`ws://${location.host}/?type=viewer`);
            ws.onopen = () => {
                document.getElementById('status').innerText = 'Connected';
                document.getElementById('status').style.color = '#0f0';
            };
            ws.onclose = () => {
                document.getElementById('status').innerText = 'Disconnected';
                document.getElementById('status').style.color = '#f00';
                setTimeout(connect, 2000);
            };
            ws.onmessage = (e) => {
                const data = JSON.parse(e.data);
                if (data.type === '3d_move') {
                    const targetPos = new THREE.Vector3(data.x, data.y + 1.0, data.z);
                    const startPos = new THREE.Vector3(0, 1.0, 0);

                    // Update crawling circle that adapts to geometry
                    updateCrawlingCircle(data.x, data.y + 1.0, data.z);

                    // Update laser line
                    laserLine.geometry.setFromPoints([startPos, targetPos]);

                    // Update info
                    document.getElementById('wall').innerText = data.wall || 'Unknown';
                    document.getElementById('valX').innerText = data.x.toFixed(2);
                    document.getElementById('valY').innerText = data.y.toFixed(2);
                    document.getElementById('valZ').innerText = data.z.toFixed(2);

                    // Dynamic color based on wall
                    const colors = { 'Front': 0x00ffff, 'Left': 0xff00ff, 'Right': 0xffff00, 'Floor': 0x00ff00, 'Back': 0xff0000 };
                    const hex = colors[data.wall] || 0xff0000;
                    laserLine.material.color.setHex(hex);
                    resultMaterial.color.setHex(hex);
                }
            };
        }

        connect();

        // Slider control para el radio del cono
        const radiusSlider = document.getElementById('radiusSlider');
        const coneRadiusLabel = document.getElementById('coneRadius');

        // Deshabilitar OrbitControls cuando se use el slider
        radiusSlider.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            controls.enabled = false;
        });

        radiusSlider.addEventListener('mouseup', (e) => {
            e.stopPropagation();
            controls.enabled = true;
        });

        radiusSlider.addEventListener('mousemove', (e) => {
            e.stopPropagation();
        });

        radiusSlider.addEventListener('input', (e) => {
            e.stopPropagation();
            const val = parseFloat(e.target.value);
            coneRadiusLabel.innerText = val.toFixed(2) + ' m';
            // Escalar uniformemente en X y Z para cambiar el radio del cono
            coneBrush.scale.set(val / DECAL_RADIUS, 1, val / DECAL_RADIUS);
            // Forzar actualización CSG inmediata
            coneBrush.updateMatrixWorld();
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>