<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniversalPointer 3D Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'Consolas', monospace;
        }

        /* Video element for texture (hidden) */
        #video {
            display: none;
        }

        /* Post-Processing Overlay (Grain + Vignette) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background:
                radial-gradient(circle, transparent 50%, rgba(0, 0, 0, 0.6) 100%),
                url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIj48ZmlsdGVyIGlkPSJub2lzZSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuNjUiIG51bU9jdGF2ZXM9IjMiIHN0aXRjaFRpbGVzPSJzdGl0Y2giLz48L2ZpbHRlcj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWx0ZXI9InVybCgjbm9pc2UpIiBvcGFjaXR5PSIwLjA1Ii8+PC9zdmc+');
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #88ff88;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(136, 255, 136, 0.2);
        }

        #dataPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            color: #ddd;
            font-size: 14px;
            min-width: 250px;
            pointer-events: auto;
            z-index: 10;
        }

        .dataBox {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            margin: 8px 0;
        }

        .dataLabel {
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .dataValue {
            color: #fff;
            font-size: 16px;
            font-weight: 500;
            font-family: 'Courier New', monospace;
        }

        #playButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #0f0;
            color: #0f0;
            cursor: pointer;
            z-index: 100;
            display: block;
        }
    </style>
</head>

<body>
    <!-- Video Source -->
    <video id="video" loop muted playsinline crossorigin="anonymous">
        <source src="videowall.mp4" type="video/mp4">
    </video>

    <!-- Overlay for atmosphere -->
    <div class="overlay"></div>

    <!-- User interaction required for audio/video sometimes -->
    <button id="playButton">CLICK TO START</button>

    <div id="info">
        <b>UniversalPointer V2</b> | Video Reveal<br>
        Status: <span id="status" style="color:#888">Connecting...</span>
    </div>

    <div id="dataPanel">
        <div
            style="color: #fff; font-size: 14px; font-weight:bold; margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 8px;">
            SENSOR METRICS
        </div>

        <div class="dataBox">
            <div class="dataLabel">Surface</div>
            <div class="dataValue" id="wall" style="color: #aaa">Scanning...</div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px;">
            <div class="dataBox">
                <div class="dataLabel">X</div>
                <div class="dataValue" id="valX">0.0</div>
            </div>
            <div class="dataBox">
                <div class="dataLabel">Y</div>
                <div class="dataValue" id="valY">0.0</div>
            </div>
            <div class="dataBox">
                <div class="dataLabel">Z</div>
                <div class="dataValue" id="valZ">0.0</div>
            </div>
        </div>

        <div class="dataBox" style="pointer-events: auto; margin-top: 15px;">
            <div class="dataLabel" style="display: flex; justify-content: space-between;">
                <span>Reveal Radius</span>
                <span id="coneRadius" style="color:#fff">3.6 m</span>
            </div>
            <input type="range" id="radiusSlider" min="0.3" max="10.0" step="0.1" value="3.6"
                style="width: 100%; margin-top: 8px; accent-color: #888; cursor: pointer;">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.3/build/index.module.js",
                "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.17/build/index.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Brush, Evaluator, INTERSECTION, ADDITION } from 'three-bvh-csg';

        // --- Video Setup ---
        const video = document.getElementById('video');
        const playBtn = document.getElementById('playButton');

        playBtn.addEventListener('click', () => {
            video.play();
            playBtn.style.display = 'none';
        });

        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.colorSpace = THREE.SRGBColorSpace;
        // Adjust texture mapping to cover the whole walls nicely
        // Assuming walls are approx same size or we want repeat
        // But video usually shouldn't repeat if it's a "screen". 
        // Let's set it to cover 1 unit roughly, or match wall UVs.
        // Wall UVs usually 0-1.
        // Let's enable wrapping just in case.
        videoTexture.wrapS = THREE.RepeatWrapping;
        videoTexture.wrapT = THREE.RepeatWrapping;
        videoTexture.repeat.set(1, 1); // 1:1 mapping to wall UVs

        // --- Advanced Texture Generation (For Dark Walls) ---
        function createRealisticCement() {
            const size = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // 1. Fractal Noise for Diffuse
            ctx.fillStyle = '#555555';
            ctx.fillRect(0, 0, size, size);
            for (let i = 0; i < 400; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const r = Math.random() * 100 + 50;
                const grd = ctx.createRadialGradient(x, y, 0, x, y, r);
                grd.addColorStop(0, `rgba(0,0,0, ${Math.random() * 0.1})`);
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd;
                ctx.fillRect(x - r, y - r, r * 2, r * 2);
            }
            for (let i = 0; i < 50000; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const grey = Math.floor(Math.random() * 50 + 80);
                ctx.fillStyle = `rgba(${grey},${grey},${grey}, 0.08)`;
                ctx.fillRect(x, y, 2, 2);
            }

            const diffuseMap = new THREE.CanvasTexture(canvas);
            diffuseMap.wrapS = THREE.RepeatWrapping;
            diffuseMap.wrapT = THREE.RepeatWrapping;
            diffuseMap.repeat.set(2, 2);

            // 2. Roughness
            const rCanvas = document.createElement('canvas');
            rCanvas.width = size;
            rCanvas.height = size;
            const rCtx = rCanvas.getContext('2d');
            rCtx.filter = 'contrast(150%) brightness(120%)';
            rCtx.drawImage(canvas, 0, 0);
            const roughnessMap = new THREE.CanvasTexture(rCanvas);
            roughnessMap.wrapS = THREE.RepeatWrapping;
            roughnessMap.wrapT = THREE.RepeatWrapping;
            roughnessMap.repeat.set(2, 2);

            // 3. Normal
            const normalCanvas = document.createElement('canvas');
            normalCanvas.width = size;
            normalCanvas.height = size;
            const nCtx = normalCanvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, size, size);
            const data = imgData.data;
            const nImgData = nCtx.createImageData(size, size);
            const nd = nImgData.data;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = (y * size + x) * 4;
                    const r1 = data[((y * size + ((x + 1) % size)) * 4)];
                    const l1 = data[((y * size + ((x - 1 + size) % size)) * 4)];
                    const d1 = data[(((y + 1) % size) * size + x) * 4];
                    const u1 = data[(((y - 1 + size) % size) * size + x) * 4];

                    const dx = (l1 - r1) * 3.0; // Stronger normal
                    const dy = (u1 - d1) * 3.0;
                    const dz = 255.0 / 1.5;

                    const len = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    nd[idx] = ((dx / len) * 0.5 + 0.5) * 255;
                    nd[idx + 1] = ((dy / len) * 0.5 + 0.5) * 255;
                    nd[idx + 2] = ((dz / len) * 0.5 + 0.5) * 255;
                    nd[idx + 3] = 255;
                }
            }
            nCtx.putImageData(nImgData, 0, 0);
            const normalMap = new THREE.CanvasTexture(normalCanvas);
            normalMap.wrapS = THREE.RepeatWrapping;
            normalMap.wrapT = THREE.RepeatWrapping;
            normalMap.repeat.set(2, 2);

            return { diffuseMap, roughnessMap, normalMap };
        }

        const { diffuseMap, roughnessMap, normalMap } = createRealisticCement();

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.FogExp2(0x080808, 0.15);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2.5, 2.5, 4.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 1.5;

        // --- Lighting ---
        const hemiLight = new THREE.HemisphereLight(0x223344, 0x111111, 0.2);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xaaccff, 0.4);
        dirLight.position.set(-5, 8, -5);
        scene.add(dirLight);

        const fillLight = new THREE.PointLight(0xffaa88, 0.5, 10);
        fillLight.position.set(5, 2, 5);
        scene.add(fillLight);

        // --- Materials ---
        const concreteParams = {
            map: diffuseMap,
            roughnessMap: roughnessMap,
            normalMap: normalMap,
            color: 0x888888,
            roughness: 0.8,
            metalness: 0.1,
            envMapIntensity: 0.5,
            side: THREE.DoubleSide
        };

        const wallMat = new THREE.MeshStandardMaterial(concreteParams);

        const floorMat = new THREE.MeshStandardMaterial({
            ...concreteParams,
            color: 0x666666,
            roughness: 0.7,
            normalScale: new THREE.Vector2(0.8, 0.8)
        });

        // --- Geometry ---
        const W = 4.0, H = 3.0, D = 5.0;

        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), wallMat);
        backWall.position.set(0, H / 2, -D / 2);
        scene.add(backWall);

        const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);

        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.set(-W / 2, H / 2, 0);
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.position.set(W / 2, H / 2, 0);
        scene.add(rightWall);

        // --- CSG & Flashlight ---
        const evaluator = new Evaluator();
        const DECAL_RADIUS = 3.6;
        const CONE_LENGTH = 20.0;

        // CSG Brushes for TARGET (the walls)
        const wallCSGMat = new THREE.MeshBasicMaterial({ visible: false });
        const wallThick = 0.05;

        const bWallBrush = new Brush(new THREE.BoxGeometry(W, H, wallThick), wallCSGMat);
        bWallBrush.position.set(0, H / 2, -D / 2); bWallBrush.updateMatrixWorld();

        const fBrush = new Brush(new THREE.BoxGeometry(W, wallThick, D), wallCSGMat);
        fBrush.position.set(0, 0, 0); fBrush.updateMatrixWorld();

        const lWallBrush = new Brush(new THREE.BoxGeometry(wallThick, H, D), wallCSGMat);
        lWallBrush.position.set(-W / 2, H / 2, 0); lWallBrush.updateMatrixWorld();

        const rWallBrush = new Brush(new THREE.BoxGeometry(wallThick, H, D), wallCSGMat);
        rWallBrush.position.set(W / 2, H / 2, 0); rWallBrush.updateMatrixWorld();

        let targetBrush = evaluator.evaluate(bWallBrush, fBrush, ADDITION);
        targetBrush.updateMatrixWorld();
        targetBrush = evaluator.evaluate(targetBrush, lWallBrush, ADDITION);
        targetBrush.updateMatrixWorld();
        targetBrush = evaluator.evaluate(targetBrush, rWallBrush, ADDITION);
        targetBrush.updateMatrixWorld();

        const coneBrush = new Brush(new THREE.ConeGeometry(DECAL_RADIUS, CONE_LENGTH, 64), wallCSGMat);
        coneBrush.geometry.translate(0, -CONE_LENGTH / 2, 0);
        scene.add(coneBrush);

        // --- VIDEO REVEAL MATERIAL ---
        // Use BasicMaterial filtering logic for the video
        // But inject alpha mask for the cone edges
        const resultMaterial = new THREE.MeshBasicMaterial({
            map: videoTexture,   // Map the video!
            color: 0xffffff,     // Full brightness
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide
        });

        const shaderUniforms = {
            uConeOrigin: { value: new THREE.Vector3() },
            uConeDir: { value: new THREE.Vector3(0, -1, 0) },
            uConeMaxRadius: { value: DECAL_RADIUS },
            uConeHeight: { value: CONE_LENGTH }
        };

        resultMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.uConeOrigin = shaderUniforms.uConeOrigin;
            shader.uniforms.uConeDir = shaderUniforms.uConeDir;
            shader.uniforms.uConeMaxRadius = shaderUniforms.uConeMaxRadius;
            shader.uniforms.uConeHeight = shaderUniforms.uConeHeight;

            shader.vertexShader = `
                varying vec3 vWorldPosition;
                ${shader.vertexShader}
            `.replace(
                '#include <worldpos_vertex>',
                `#include <worldpos_vertex>
                 vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;`
            );

            shader.fragmentShader = `
                uniform vec3 uConeOrigin;
                uniform vec3 uConeDir;
                uniform float uConeMaxRadius;
                uniform float uConeHeight;
                varying vec3 vWorldPosition;
                
                ${shader.fragmentShader}
            `.replace(
                '#include <dithering_fragment>',
                `#include <dithering_fragment>
                
                // --- CSG Soft Edge Logic ---
                vec3 toFrag = vWorldPosition - uConeOrigin;
                float axisProj = dot(toFrag, uConeDir);
                float safeProj = max(0.0, axisProj);
                float currentRadius = (safeProj / uConeHeight) * uConeMaxRadius;
                
                vec3 closestPoint = uConeOrigin + uConeDir * axisProj;
                float dist = length(vWorldPosition - closestPoint);
                
                // Soft Edge Falloff
                float softness = 0.25; 
                float edgeStart = currentRadius * (1.0 - softness);
                float alpha = 1.0 - smoothstep(edgeStart, currentRadius, dist);
                
                gl_FragColor.a *= alpha;
                
                // Slight boost to make video pop against contrast
                gl_FragColor.rgb *= 1.1; 
                `
            );
        };

        const resultMesh = new THREE.Mesh(new THREE.BufferGeometry(), resultMaterial);
        // Prioritize over wall to prevent z-fighting
        resultMaterial.polygonOffset = true;
        resultMaterial.polygonOffsetFactor = -4;
        scene.add(resultMesh);

        // --- WebSocket & Update ---
        function updateCone(x, y, z) {
            const origin = new THREE.Vector3(0, 1.0, 0); // Head height
            const target = new THREE.Vector3(x, y, z);
            const dir = new THREE.Vector3().subVectors(target, origin).normalize();

            coneBrush.position.copy(origin);
            coneBrush.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dir);
            coneBrush.updateMatrixWorld();

            shaderUniforms.uConeOrigin.value.copy(origin);
            shaderUniforms.uConeDir.value.copy(dir);

            try {
                targetBrush.updateMatrixWorld();
                const res = evaluator.evaluate(targetBrush, coneBrush, INTERSECTION);
                if (res && res.geometry) {
                    if (resultMesh.geometry) resultMesh.geometry.dispose();
                    resultMesh.geometry = res.geometry;
                    resultMesh.visible = res.geometry.attributes.position.count > 0;
                }
            } catch (e) { }
        }

        let ws;
        function connect() {
            const statusEl = document.getElementById('status');
            ws = new WebSocket(`ws://${location.host}/?type=viewer`);
            ws.onopen = () => { statusEl.innerText = 'Online'; statusEl.style.color = '#8f8'; };
            ws.onclose = () => { statusEl.innerText = 'Offline'; statusEl.style.color = '#f88'; setTimeout(connect, 2000); };
            ws.onmessage = (e) => {
                const d = JSON.parse(e.data);
                if (d.type === '3d_move') {
                    updateCone(d.x, d.y + 1.0, d.z);
                    document.getElementById('wall').innerText = d.wall;
                    document.getElementById('valX').innerText = d.x.toFixed(2);
                    document.getElementById('valY').innerText = d.y.toFixed(2);
                    document.getElementById('valZ').innerText = d.z.toFixed(2);
                }
            };
        }
        connect();

        // --- Slider ---
        const slider = document.getElementById('radiusSlider');
        slider.addEventListener('mousedown', (e) => { e.stopPropagation(); controls.enabled = false; });
        slider.addEventListener('mouseup', (e) => { e.stopPropagation(); controls.enabled = true; });
        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('coneRadius').innerText = val.toFixed(1) + ' m';
            coneBrush.scale.set(val / DECAL_RADIUS, 1, val / DECAL_RADIUS);
            coneBrush.updateMatrixWorld();
            shaderUniforms.uConeMaxRadius.value = val;
        });

        // --- Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>